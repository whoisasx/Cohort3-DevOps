* go through the notes of previous class before attending the next one.

# week 24.1
1. create a digital ocean account.
    - using ssh key for verification.
    - generate the ssh key on the local machine inside the .ssh folder and using 
      the command 'ssh-keygen'.
2. serve a demo webpage over there.
3. access it by the public domain.

#week 24.2
1.get a GCP account and initiate a virutal machine. 
2.replace nginx with traefic/HAproxy/apache.
3.try deploying a react project.
4.get a domain (namecheap). DONE
5.try ASGs
6.try to do certificate managaement yourself.
7.create a ci/cd pipeline to auto deploy your server from github.
8.forever or pm2(process management)

------------------------------------------------------------------------------------------------

#week 25.2
1. create a monorepo with apps (ws, http, web) and each of them to database and push it to github.
2.  - create 2 servers.
    - add node, nginx to both the servers and also the pnpm.
    - clone the monorepo to both the servers.
    - start all three process http,ws and web.
    - point the name to the specific servers.
    - also deploy the staging websites. 
    - refresh ngnix config.
    - test everything is working.
3. create a ci/cd pipeline.

    {
        whenever we open a terminal anywhere, it automatically source the shell files like (.bashrc,zshrc etc.) but only in the interactive shell. so if we manually ssh into the virtual machine(vm) the shell is interactive and hence the shell files are sourced and we get desired access to the nvm , node , npm and all if they are already installed.
        but in case of github, when github server ssh into the vm , its shell is non-interactive and hence no shell files are sourced and hence no access to anything like node,nvm or npm.
        it will display:[Pseudo-terminal will not be allocated because stdin is not a terminal.]

        even though you manually include the command to source nvm in the deployment file, it still misses the path where all the commands are stored of node and all.
    }

----------------------------------------------------------------------------------------------

#week 26.1
1. install docker Desktop and sign up.
    - run mongo image locally and also remove it.
2. docker image v/s container.
    - image: standalone package contains or encapsulate everything required to run a piece of software. [analogy: consider it as a class.]
    - container: an instance of an image and may be created many more. [analogy: consider an object of a class]
3. understand the concept of port mapping.
4. common docker commands.
    - docker run/kill
    - docker ps/exec
    - docker images
    - docker push
    - docker build [creating your own docker image.]
5. create a docker image locally.
    -build and run a container of the image.
    -push it on docker and remove it from local machine and then run it again to pull it locally.

#week 26.2
1. layers in docker.
    - caching and optimising the cached layers to optimise the build process.
    - always try to use cached layer from previous build if it's not dependent or unchanged.
2. volumes in docker.
3. networks in docker.

--------------------------------------------------------------------------------------------

#week 27.1
1. docker-compose 
2. create a monorepo, and write CI/CD pipeline to deploy it.
Task: monorepo deployment to VM via CI/CD using docker.

-----------------------------------------------------------------------
#week 27.2
Task: Deploying a monorepo to a VM using Docker and CI/CD

1. Use Bun as a package manager for all apps in the monorepo.
   - Understand SSG, CSR, SSR, ISR in Next.js.
   - Clarify the difference between edge and non-edge environments.
   - Note: In Next.js App Router, by default every page is SSG at build time. Next.js decides which pages to statically generate. If a page uses SSG and fetches data from a database, the database connection is needed at build time. This is why you must provide the database URL as a build argument (BUILD ARG) for web apps. For HTTP and WebSocket servers, database access is only needed at runtime, not build time.

2. Create a simple monorepo structure:
   - apps/
     - http-server
     - ws-server
     - web (Next.js)
   - packages/
     - db (Prisma, shared types, etc.)
     - ui (shared UI components)

3. Write a Dockerfile for each app:
   - Use multi-stage builds for smaller images.
   - For web (Next.js):
     - Use `ARG` for `DATABASE_URL` at build time for SSG.
     - Use `ENV` or `env_file` for runtime variables.
   - For http-server and ws-server:
     - Only set `DATABASE_URL` as an environment variable for runtime.

4. Write a `docker-compose.yml`:
   - Define services for each app and the database (e.g., Postgres).
   - Use `env_file` for runtime secrets/configs.
   - Use build `args` for web app build-time variables.
   - Use named volumes for database persistence.
   - Example:
     - `DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/postgres`
     - `POSTGRES_PASSWORD` in root `.env` for the database container.

5. Write a CI/CD pipeline:
   - Build and push Docker images to a registry (e.g., Docker Hub).
   - SSH into the VM and pull the latest images.
   - Use `docker-compose` to start/restart the services.
   - Automate the process using GitHub Actions or another CI/CD tool.

6. (Optional) Add health checks, logging, and monitoring for production readiness.

---

This structure ensures clear separation of build-time and runtime configs, secure handling of secrets, and a repeatable deployment process for your monorepo.